import gmpy2

# Abbiamo due ciphertexts (c1, c2) derivanti dalla cifratura di uno stesso messaggio m con diverse chiavi pubbliche note (e1, e2) e uno stesso modulo n.
# Per ottenere il messaggio m è necessario trovare i coefficienti x e y tali che e1x + e2y = 1 mod n. Tali coefficienti sono rispettivamente -3 e 2.
# Scriviamo quindi m^(e1x+e2y) che sarà uguale a m modulo n. Per fare ciò è necessario elevare c2^y e (c1^(-1))^(-x) trovando quindi l'inverso di c1 modulo n.
# Il risultato della computazione viene stampato
n = 1200867589138402836833011627922648843865398758356119243237528992192661195883356632897345588719304934438534205354787918897834861577085344762327143956220911721261528444200091612203799709834594997775067917847690315178675148605331912292785817786238119642200812571328900475396454557843711810878201457471117182510681991129539167165552073440243913144926216242708247975357913354302233984628116835035339887667027876020733894592318754941490852771134623356130705203596572659
c1 = 13740701343175031613859506260680271
c2 = 442020648620790478265510268903148188611479520134128911
c1_new = pow(gmpy2.invert(c1, n),3, n)
c2_new = pow(c2,2,n)
m = c1_new*c2_new %n
print(m)